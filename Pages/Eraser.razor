@page "/color-remover"
@using System.Drawing
@inject IJSRuntime JSRuntime

<PageTitle>Color Remover Tool</PageTitle>
<h1 style="cursor: pointer;" @onclick="ToggleDescription">Color Remover Tool</h1>
<div class="left_display">
    @if (!showDescription)
    {
        <div class="sticky_left">
            <p>Upload an image and automatically detect the most prevalent color, then remove or replace it. Perfect for removing backgrounds or changing specific colors in your images.</p>
            <p><strong>How to use:</strong></p>
            <ul>
                <li>Click "Choose File" to upload an image (JPG, PNG, etc.)</li>
                <li>The tool will automatically detect the most common color</li>
                <li>Adjust the target color using the color picker if needed</li>
                <li>Choose to either remove the color (make transparent) or replace it with another color</li>
                <li>Use the tolerance slider to fine-tune which similar colors to process</li>
                <li>Preview the result and download your processed image</li>
            </ul>
            <p><strong>Tips:</strong> Higher tolerance values will affect more similar colors. Lower values will be more precise but may leave some pixels unchanged.</p>
        </div>
    }

    <!-- Upload Section -->
    @if (showDescription)
    {
        <div class="upload-section">
            <h3>Upload Image</h3>
            <InputFile OnChange="HandleFileSelected" accept="image/*" class="file-input" />
            @if (isProcessing)
            {
                <div class="processing-indicator">
                    <span>Processing image...</span>
                </div>
            }
        </div>

        @if (!string.IsNullOrEmpty(originalImageDataUrl))
        {
            <!-- Color Controls Section -->
            <div class="controls-section">
                <div class="first-row">
                    <label class="text_box_label">Detected Color:</label>
                    <div class="color-display" style="background-color: @detectedColor;"></div>
                    <span class="color-text">@detectedColor</span>
                </div>

                <div class="second-row">
                    <label class="text_box_label" for="colorPicker">Color to Process:</label>
                    <input type="color" id="colorPicker" class="color-picker"
                           value="@selectedColor" @onchange="OnColorChanged" />
                </div>

                <div class="third-row">
                    <label class="text_box_label">Action:</label>
                    <div class="action-controls">
                        <input type="radio" id="remove" name="action" value="remove"
                               checked="@(actionType == "remove")" @onchange="OnActionChanged" />
                        <label for="remove" class="radio-label">Remove (Transparent)</label>

                        <input type="radio" id="replace" name="action" value="replace"
                               checked="@(actionType == "replace")" @onchange="OnActionChanged" />
                        <label for="replace" class="radio-label">Replace with Color</label>
                    </div>
                </div>

                @if (actionType == "replace")
                {
                    <div class="fourth-row">
                        <label class="text_box_label" for="replacementColor">Replacement Color:</label>
                        <input type="color" id="replacementColor" class="color-picker"
                               value="@replacementColor" @onchange="OnReplacementColorChanged" />
                    </div>
                }

                <div class="@(actionType == "replace" ? "fifth-row" : "fourth-row")">
                    <label class="text_box_label" for="tolerance">Tolerance (@tolerance):</label>
                    <input type="range" id="tolerance" class="tolerance-slider"
                           min="0" max="255" value="@tolerance" @onchange="OnToleranceChanged" />
                </div>

                <div class="button_wrapper">
                    <button @onclick="ProcessImage" disabled="@isProcessing">
                        Update Preview
                    </button>
                </div>
            </div>

            <!-- Images Display Section -->
            <div class="images-section">
                <div class="image-container">
                    <h4>Original Image</h4>
                    <img src="@originalImageDataUrl" alt="Original" class="preview-image" />
                </div>

                @if (!string.IsNullOrEmpty(processedImageDataUrl))
                {
                    <div class="image-container">
                        <h4>Processed Image</h4>
                        <img src="@processedImageDataUrl" alt="Processed" class="preview-image" />
                        <div class="button_wrapper">
                            <button @onclick="DownloadImage">
                                Download
                            </button>
                        </div>
                    </div>
                }
            </div>
        }
    }
</div>

@code {
    private string originalImageDataUrl = "";
    private string processedImageDataUrl = "";
    private string detectedColor = "#000000";
    private string selectedColor = "#000000";
    private string replacementColor = "#ffffff";
    private string actionType = "remove";
    private int tolerance = 30;
    private bool isProcessing = false;
    private string originalFileName = "";
    private bool showDescription = true; // Start with description visible, tool hidden

    private void ToggleDescription()
    {
        showDescription = !showDescription;
    }

    private async Task OnActionChanged(ChangeEventArgs e)
    {
        actionType = e.Value?.ToString() ?? "remove";
        if (!string.IsNullOrEmpty(originalImageDataUrl))
        {
            await ProcessImage();
        }
    }

    private async Task OnReplacementColorChanged(ChangeEventArgs e)
    {
        replacementColor = e.Value?.ToString() ?? "#ffffff";
        if (!string.IsNullOrEmpty(originalImageDataUrl))
        {
            await ProcessImage();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("initializeColorRemover");
        }
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        var file = e.File;
        if (file != null)
        {
            originalFileName = file.Name;
            isProcessing = true;
            StateHasChanged();

            try
            {
                // Read file as base64
                var buffer = new byte[file.Size];
                await file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024).ReadAsync(buffer);
                var base64 = Convert.ToBase64String(buffer);
                originalImageDataUrl = $"data:{file.ContentType};base64,{base64}";

                // Detect most prevalent color
                var colorResult = await JSRuntime.InvokeAsync<string>("detectMostPrevalentColor", originalImageDataUrl);
                detectedColor = colorResult;
                selectedColor = colorResult;

                StateHasChanged();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error processing file: {ex.Message}");
            }
            finally
            {
                isProcessing = false;
                StateHasChanged();
            }
        }
    }

    private async Task OnColorChanged(ChangeEventArgs e)
    {
        selectedColor = e.Value?.ToString() ?? "#000000";
        await ProcessImage();
    }

    private async Task OnToleranceChanged(ChangeEventArgs e)
    {
        tolerance = int.Parse(e.Value?.ToString() ?? "30");
        await ProcessImage();
    }

    private async Task ProcessImage()
    {
        if (string.IsNullOrEmpty(originalImageDataUrl)) return;

        isProcessing = true;
        StateHasChanged();

        try
        {
            if (actionType == "remove")
            {
                processedImageDataUrl = await JSRuntime.InvokeAsync<string>("removeColor",
                    originalImageDataUrl, selectedColor, tolerance);
            }
            else
            {
                processedImageDataUrl = await JSRuntime.InvokeAsync<string>("replaceColor",
                    originalImageDataUrl, selectedColor, replacementColor, tolerance);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error processing image: {ex.Message}");
        }
        finally
        {
            isProcessing = false;
            StateHasChanged();
        }
    }

    private async Task DownloadImage()
    {
        if (!string.IsNullOrEmpty(processedImageDataUrl))
        {
            var fileNameWithoutExt = originalFileName.Contains('.')
                ? originalFileName.Substring(0, originalFileName.LastIndexOf('.'))
                : originalFileName;
            var fileName = fileNameWithoutExt + "_processed.png";
            await JSRuntime.InvokeVoidAsync("downloadImage", processedImageDataUrl, fileName);
        }
    }
}

<script>
    window.initializeColorRemover = () => {
        console.log("Color Remover initialized");
    };

    window.detectMostPrevalentColor = (imageDataUrl) => {
        return new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const colorCount = {};

                // Sample every 4th pixel for performance
                for (let i = 0; i < data.length; i += 16) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const a = data[i + 3];

                    if (a > 128) { // Only count non-transparent pixels
                        const color = `${r},${g},${b}`;
                        colorCount[color] = (colorCount[color] || 0) + 1;
                    }
                }

                let maxCount = 0;
                let mostPrevalentColor = '0,0,0';
                for (const color in colorCount) {
                    if (colorCount[color] > maxCount) {
                        maxCount = colorCount[color];
                        mostPrevalentColor = color;
                    }
                }

                const [r, g, b] = mostPrevalentColor.split(',').map(Number);
                const hex = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
                resolve(hex);
            };
            img.src = imageDataUrl;
        });
    };

    window.removeColor = (imageDataUrl, colorToRemove, tolerance) => {
        return new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;

                // Convert hex color to RGB
                const targetR = parseInt(colorToRemove.slice(1, 3), 16);
                const targetG = parseInt(colorToRemove.slice(3, 5), 16);
                const targetB = parseInt(colorToRemove.slice(5, 7), 16);

                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    // Calculate color distance
                    const distance = Math.sqrt(
                        Math.pow(r - targetR, 2) +
                        Math.pow(g - targetG, 2) +
                        Math.pow(b - targetB, 2)
                    );

                    // If color is within tolerance, make it transparent
                    if (distance <= tolerance) {
                        data[i + 3] = 0; // Set alpha to 0 (transparent)
                    }
                }

                ctx.putImageData(imageData, 0, 0);
                resolve(canvas.toDataURL('image/png'));
            };
            img.src = imageDataUrl;
        });
    };

    window.replaceColor = (imageDataUrl, colorToReplace, replacementColor, tolerance) => {
        return new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;

                // Convert hex colors to RGB
                const targetR = parseInt(colorToReplace.slice(1, 3), 16);
                const targetG = parseInt(colorToReplace.slice(3, 5), 16);
                const targetB = parseInt(colorToReplace.slice(5, 7), 16);

                const newR = parseInt(replacementColor.slice(1, 3), 16);
                const newG = parseInt(replacementColor.slice(3, 5), 16);
                const newB = parseInt(replacementColor.slice(5, 7), 16);

                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    // Calculate color distance
                    const distance = Math.sqrt(
                        Math.pow(r - targetR, 2) +
                        Math.pow(g - targetG, 2) +
                        Math.pow(b - targetB, 2)
                    );

                    // If color is within tolerance, replace it
                    if (distance <= tolerance) {
                        data[i] = newR;     // Red
                        data[i + 1] = newG; // Green
                        data[i + 2] = newB; // Blue
                        // Keep original alpha
                    }
                }

                ctx.putImageData(imageData, 0, 0);
                resolve(canvas.toDataURL('image/png'));
            };
            img.src = imageDataUrl;
        });
    };

    window.downloadImage = (dataUrl, filename) => {
        const link = document.createElement('a');
        link.download = filename;
        link.href = dataUrl;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    };
</script>

