@page "/companion"
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div id="playground">
    <div id="cursor"></div>
    <div id="info">
        <div>3D ASCII Centipede Companion</div>
        <div>Click: Feed • Hold: Attract</div>
        <div>State: <span id="state">Wandering</span></div>
        <div>Energy: <span id="energy">100</span>%</div>
    </div>
</div>

@code
{
    private IJSObjectReference? jsModule;
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("initializeCentipede");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error initializing centipede: {ex.Message}");
            }
        }
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("cleanupCentipede");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during cleanup: {ex.Message}");
        }

        if (jsModule != null)
        {
            await jsModule.DisposeAsync();
        }
    }
}

<script>
    let centipedeInstance = null;
    this.mouseVelocity = { x: 0, y: 0 };
    this.lastMousePos = { x: 0, y: 0 };
    this.lastMouseTime = performance.now();

    window.initializeCentipede = () => {
        if (centipedeInstance) {
            centipedeInstance.cleanup();
        }
        setTimeout(() => {
            centipedeInstance = new AsciiCentipede();
        }, 100);
    };

    window.cleanupCentipede = () => {
        if (centipedeInstance) {
            centipedeInstance.cleanup();
            centipedeInstance = null;
        }
    };

    class AsciiCentipede {
        constructor() {
            this.playground = document.getElementById('playground');
            this.cursor = document.getElementById('cursor');
            this.segments = [];
            this.length = 31; //number of segments
            this.segmentWidth = 5; // Number of characters per segment
            this.position = { x: window.innerWidth / 2, y: window.innerHeight / 2, z: 0 };
            this.velocity = { x: 0, y: 0, z: 0 };
            this.targetPosition = null;
            this.state = 'wandering';
            this.energy = 100;
            this.time = 0;
            this.mousePos = { x: 0, y: 0 };
            this.isMouseDown = false;
            this.animationId = null;
            this.isDestroyed = false;

            //mouse tracking
            this.mousePos = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
            this.lastMousePos = { x: this.mousePos.x, y: this.mousePos.y };
            this.lastMouseTime = performance.now();
            this.mouseVelocity = { x: 0, y: 0 }; // px/ms
            this.mouseSpeedEMA = 0;// smoothed scalar speed (px/ms)


            // 3D rotation angles for each segment
            this.segmentRotations = new Array(this.length).fill(0);
            this.rotationSpeeds = [];

            // Initialize rotation speeds for each segment
            for (let i = 0; i < this.length; i++) {
                this.rotationSpeeds[i] = (Math.random() - 0.5) * 0.1;
            }

            this.asciiPatterns = [
                ['◊◈◇◉●', '○◦·∘◯', '◐◑◒◓◔', '◕◖◗◘◙', '◚◛◜◝◞'],
                ['▓▒░█▄', '▀■□▪▫', '◼◻▬▭▮', '▯▰▱▲▴', '▵▶▷▸▹'],
                ['※✱✲✳✴', '✵✶✷✸✹', '✺✻✼✽✾', '✿❀❁❂❃', '❄❅❆❇❈'],
                ['◆◇◈◉◊', '●◎◐◑◒', '◓◔◕◖◗', '◘◙◚◛◜', '◝◞◟◠◡'],
                ['⚬⚭⚮⚯⚰', '⚱⚲⚳⚴⚵', '⚶⚷⚸⚹⚺', '⚻⚼⚽⚾⚿', '⛀⛁⛂⛃⛄'],
                ['♠♣♥♦★', '☀☁☂☃☄', '☉☊☋☌☍', '☽☾☿♀♂', '♈♉♊♋♌'],
                ['⊙⊚⊛⊜⊝', '◍◎◉◌◍', '⚪⚫⚽⚾⛳', '⦿⦾⦻⦺⦹', '⦶⦷⦸⦵⦴'],
                ['▤▥▦▧▨', '▩▪▫▭▮', '▯▰▱▲△', '◰◱◲◳◴', '◵◶◷◸◹'],
                ['⌁⌂⌃⌄⌅', '⌆⌇⌈⌉⌊', '⌋⌌⌍⌎⌏', '⎀⎁⎂⎃⎄', '⎅⎆⎇⎈⎉'],
                ['☌☍☊☋☇', '☈☉☊☋☌', '☍☎☏☑☒', '☓☔☕☖☗', '☘☙☚☛☜'],
                ['╔╗╚╝╠╣', '═║╦╩╬', '┌┐└┘├┤', '─┼┬┴┽', '▌▐▔▕▖']

            ];

            this.currentPattern = 0;
            this.patternTimer = 0;

            if (this.playground) {
                this.init();
                this.bindEvents();
                this.animate();
            }
        }

        init() {
            if (!this.playground) return;

            // Clear any existing segments
            const existingSegments = this.playground.querySelectorAll('.centipede-segment');
            existingSegments.forEach(segment => segment.remove());

            // Get current viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Set initial position to center of screen
            this.position.x = viewportWidth / 2;
            this.position.y = viewportHeight / 2;

            console.log(`Initializing centipede at: ${this.position.x}, ${this.position.y}`);
            console.log(`Viewport: ${viewportWidth} x ${viewportHeight}`);

            // Create centipede segments
            for (let i = 0; i < this.length; i++) {
                const segment = document.createElement('div');
                segment.className = 'centipede-segment';
                if (i === 0) segment.classList.add('head');
                if (i === this.length - 1) segment.classList.add('tail');

                // Force inline styles to override any Blazor CSS conflicts
                segment.style.cssText = `
                    position: absolute !important;
                    font-family: 'Consolas', monospace !important;
                    font-size: ${i === 0 ? '20px' : i === this.length - 1 ? '12px' : '16px'} !important;
                    font-weight: bold !important;
                    color: ${i === 0 ? '#333' : i === this.length - 1 ? '#e5e5e5' : '#e5e5e5'} !important;
                    text-shadow: 0 0 10px currentColor, 0 0 20px currentColor !important;
                    user-select: none !important;
                    z-index: ${20 - i} !important;
                    width: auto !important;
                    height: auto !important;
                    display: inline-block !important;
                    margin: 0 !important;
                    padding: 0 !important;
                    border: none !important;
                    background: transparent !important;
                    letter-spacing: ${i === 0 ? '2px' : i === this.length - 1 ? '1px' : '3px'} !important;
                    transform-origin: center center !important;
                    transition: transform 0.1s ease-out !important;
                `;

                const initialX = this.position.x - i * 25;
                const initialY = this.position.y + Math.sin(i * 0.5) * 10;

                segment.textContent = this.getSegmentChar(i);
                segment.style.left = initialX + 'px';
                segment.style.top = initialY + 'px';

                console.log(`Segment ${i}: ${segment.textContent} at (${initialX}, ${initialY})`);

                this.playground.appendChild(segment);
                this.segments.push({
                    element: segment,
                    x: initialX,
                    y: initialY,
                    z: 0,
                    targetX: initialX,
                    targetY: initialY
                });
            }

            console.log(`Created ${this.segments.length} segments`);
        }

        getSegmentChar(index) {
            const pattern = this.asciiPatterns[this.currentPattern];
            const rotationIndex = Math.floor(this.segmentRotations[index]) % pattern.length;
            const segmentPattern = pattern[rotationIndex < 0 ? pattern.length + rotationIndex : rotationIndex];

            if (index === 0) {
                // Head - show direction with arrow-like pattern
                const headPatterns = ['►►►►►', '▶▶▶▶▶', '»»»»»', '→→→→→', '⟩⟩⟩⟩⟩'];
                const headIndex = Math.floor(this.segmentRotations[index] / 2) % headPatterns.length;
                return headPatterns[headIndex < 0 ? headPatterns.length + headIndex : headIndex];
            } else if (index === this.length - 1) {
                // Tail - smaller, fading pattern
                const tailPatterns = ['◦◦◦', '··', '∘', '○', '●'];
                const tailIndex = Math.floor(this.segmentRotations[index] / 3) % tailPatterns.length;
                return tailPatterns[tailIndex < 0 ? tailPatterns.length + tailIndex : tailIndex];
            } else {
                // Body segments - full 3D screw effect
                return segmentPattern;
            }
        }

        bindEvents() {
            this.mouseMoveHandler = (e) => {
                const now = performance.now();
                const dt = Math.max(1, now - this.lastMouseTime); // ms

                const dx = e.clientX - this.lastMousePos.x;
                const dy = e.clientY - this.lastMousePos.y;
                const instSpeed = Math.hypot(dx, dy) / dt; // px/ms

                // smooth the speed to avoid jitter
                const alpha = 0.3;
                this.mouseSpeedEMA += alpha * (instSpeed - this.mouseSpeedEMA);

                // keep vector too (can be useful for effects)
                this.mouseVelocity.x = dx / dt;
                this.mouseVelocity.y = dy / dt;

                this.lastMousePos.x = e.clientX;
                this.lastMousePos.y = e.clientY;
                this.lastMouseTime = now;

                this.mousePos.x = e.clientX;
                this.mousePos.y = e.clientY;

                if (this.cursor) {
                    this.cursor.style.left = e.clientX - 10 + 'px';
                    this.cursor.style.top = e.clientY - 10 + 'px';
                }
            };

            this.mouseDownHandler = (e) => {
                this.isMouseDown = true;
                this.feed(e.clientX, e.clientY);
                this.setState('following');
            };

            this.mouseUpHandler = () => {
                this.isMouseDown = false;
                setTimeout(() => {
                    if (!this.isMouseDown) {
                        this.setState('wandering');
                    }
                }, 1000);
            };

            //this.keyDownHandler = (e) => {
            //    if (e.code === 'Space') {
            //        e.preventDefault();
            //        this.boost();
            //    }
            //};

            document.addEventListener('mousemove', this.mouseMoveHandler);
            document.addEventListener('mousedown', this.mouseDownHandler);
            document.addEventListener('mouseup', this.mouseUpHandler);
            //document.addEventListener('keydown', this.keyDownHandler);
        }

        setState(newState) {
            this.state = newState;
            const stateElement = document.getElementById('state');
            if (stateElement) {
                stateElement.textContent = this.capitalizeFirst(newState);
            }
        }

        capitalizeFirst(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        feed(x, y) {
            this.energy = Math.min(100, this.energy + 10);
            this.createParticles(x, y, '♥');
            this.setState('eating');
            setTimeout(() => {
                if (!this.isMouseDown) this.setState('wandering');
            }, 500);
        }

        //boost() {
        //    if (this.energy >= 20) {
        //        this.energy -= 20;
        //        this.setState('boosting');
        //        this.velocity.x *= 2;
        //        this.velocity.y *= 2;
        //
        //        // Boost rotation speeds during boost
        //        this.rotationSpeeds = this.rotationSpeeds.map(speed => speed * 3);
        //
        //           this.evolve();
        //    setTimeout(() => {
        //             this.setState('wandering');
        //           // Restore normal rotation speeds
        //          this.rotationSpeeds = this.rotationSpeeds.map(speed => speed / 3);
        //     }, 1000);
        //}
        //}

        evolve() {
            this.currentPattern = (this.currentPattern + 1) % this.asciiPatterns.length;

            // Randomize rotation speeds when evolving
            for (let i = 0; i < this.length; i++) {
                this.rotationSpeeds[i] = (Math.random() - 0.5) * 0.15;
            }

            this.updateSegmentChars();
            if (this.segments.length > 0) {
                this.createParticles(this.segments[0].x, this.segments[0].y, '✨');

                // Create evolution burst effect
                for (let i = 0; i < this.segments.length; i++) {
                    setTimeout(() => {
                        this.createParticles(
                            this.segments[i].x + (Math.random() - 0.5) * 30,
                            this.segments[i].y + (Math.random() - 0.5) * 30,
                            ['⚡', '✨', '💫', '⭐'][Math.floor(Math.random() * 4)]
                        );
                    }, i * 100);
                }
            }
        }

        updateSegmentChars() {
            this.segments.forEach((segment, index) => {
                if (segment.element) {
                    segment.element.textContent = this.getSegmentChar(index);
                }
            });
        }

        createParticles(x, y, char) {
            if (!this.playground) return;

            for (let i = 0; i < 5; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.textContent = char;
                particle.style.left = (x + (Math.random() - 0.5) * 50) + 'px';
                particle.style.top = (y + (Math.random() - 0.5) * 50) + 'px';
                this.playground.appendChild(particle);

                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.remove();
                    }
                }, 3000);
            }
        }

        updateMovement() {
            if (this.isDestroyed) return;

            // time/energy housekeeping
            this.time += 0.05;
            this.energy = Math.max(0, this.energy - 0.02);

            // periodic pattern change
            this.patternTimer++;
            if (this.patternTimer > 300) {
                this.patternTimer = 0;
                this.currentPattern = (this.currentPattern + 1) % this.asciiPatterns.length;
                this.updateSegmentChars();
            }

            // ---- FOLLOW / WANDER LOGIC ----
            if (this.segments.length > 0) {
                const head = this.segments[0];

                if (this.state === 'following' && this.isMouseDown) {
                    // vector from head to mouse
                    const dx = this.mousePos.x - head.x;
                    const dy = this.mousePos.y - head.y;
                    const dist = Math.hypot(dx, dy) || 1;

                    // desired direction
                    const dirX = dx / dist;
                    const dirY = dy / dist;

                    // convert mouse speed (px/ms) to “px/frame” scale
                    // 16 ~ typical ms/frame; tune kMouse, kBase to taste
                    const kMouse = 16 * 1.0;   // sensitivity to mouse speed
                    const kBase  = 1.4;        // base minimum speed (20% faster than 1.2-ish)
                    let desiredSpeed = kBase + kMouse * this.mouseSpeedEMA;

                    // near the cursor: taper speed so we don't overshoot
                    const deadzone = 30;
                    if (dist < deadzone) {
                        desiredSpeed *= (dist / deadzone);
                    }

                    // cap based on how wild mouse moves can be
                    const maxSpeed = Math.max(3.0, Math.min(6.0, desiredSpeed * 1.5));
                    desiredSpeed = Math.min(desiredSpeed, maxSpeed);

                    // target velocity toward the cursor at the chosen speed
                    const vTargetX = dirX * desiredSpeed;
                    const vTargetY = dirY * desiredSpeed;

                    // blend current velocity toward target (steering)
                    const responsiveness = 0.22; // 0..1 higher = snappier
                    this.velocity.x += (vTargetX - this.velocity.x) * responsiveness;
                    this.velocity.y += (vTargetY - this.velocity.y) * responsiveness;

                } else {
                    // wandering (keep your faster-by-20% feel)
                    this.velocity.x += (Math.random() - 0.5) * 0.36;
                    this.velocity.y += (Math.random() - 0.5) * 0.36;
                    this.velocity.x += Math.sin(this.time * 0.5) * 0.24;
                    this.velocity.y += Math.cos(this.time * 0.3) * 0.24;
                }

                // energy influence & damping
                const energyMultiplier = (this.energy / 100) * 1 + 0.5; // was *0.5
                this.velocity.x *= energyMultiplier;
                this.velocity.y *= energyMultiplier;

                this.velocity.x *= 0.95;
                this.velocity.y *= 0.95;

                // final clamping (keeps things sane if mouse flicks)
                const vMag = Math.hypot(this.velocity.x, this.velocity.y);
                const hardMax = 6.0; // slightly above the 20% boosted cap
                if (vMag > hardMax) {
                    this.velocity.x = (this.velocity.x / vMag) * hardMax;
                    this.velocity.y = (this.velocity.y / vMag) * hardMax;
                }

                // advance head target
                head.targetX += this.velocity.x;
                head.targetY += this.velocity.y;

                // keep inside viewport
                head.targetX = Math.max(20, Math.min(window.innerWidth  - 20, head.targetX));
                head.targetY = Math.max(20, Math.min(window.innerHeight - 20, head.targetY));

                // bounce if we hit edges
                if (head.x <= 0 || head.x >= window.innerWidth)  this.velocity.x *= -0.8;
                if (head.y <= 0 || head.y >= window.innerHeight) this.velocity.y *= -0.8;
            }
        }


        updateSegments() {
            if (this.isDestroyed || this.segments.length === 0) return;

            this.segments[0].x += (this.segments[0].targetX - this.segments[0].x) * 0.1;
            this.segments[0].y += (this.segments[0].targetY - this.segments[0].y) * 0.1;

            for (let i = 1; i < this.segments.length; i++) {
                const prevSegment = this.segments[i - 1];
                const currentSegment = this.segments[i];

                const dx = prevSegment.x - currentSegment.x;
                const dy = prevSegment.y - currentSegment.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const targetDistance = 25;

                if (distance > targetDistance) {
                    const moveX = (dx / distance) * (distance - targetDistance);
                    const moveY = (dy / distance) * (distance - targetDistance);

                    currentSegment.x += moveX * 0.3;
                    currentSegment.y += moveY * 0.3;
                }

                currentSegment.y += Math.sin(this.time * 2 + i * 0.3) * 1.5;
            }

            this.segments.forEach((segment, index) => {
                if (segment.element) {
                    // Update position
                    segment.element.style.left = segment.x + 'px';
                    segment.element.style.top = segment.y + 'px';

                    // Update 3D rotation - each segment rotates at its own speed
                    ////this.segmentRotations[index] += this.rotationSpeeds[index] * (this.energy / 50 + 0.5);
                    // Add movement-based rotation boost
                    ////const speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
                    ////this.segmentRotations[index] += speed * 0.05;

                    // Shared base rotation
                    const baseRotationSpeed = 0.05 * 1.5 * (this.energy / 50 + 0.5);
                    const speed = Math.hypot(this.velocity.x, this.velocity.y);
                    const movementBoost = speed * 0.03 * 1.5;
                    this.segmentRotations[index] = this.time * (baseRotationSpeed + movementBoost) + index * 0.3;


                    // Calculate 3D transform
                    const zOffset = Math.sin(this.time + index * 0.2) * 5;
                    const rotationY = this.segmentRotations[index] * 10; // Convert to degrees
                    const rotationZ = Math.sin(this.time * 0.5 + index * 0.3) * 5;
                    const scale = 1 + (Math.sin(this.segmentRotations[index]) * 0.1);

                    // Apply complex 3D transformation
                    segment.element.style.transform = `
                        translateZ(${zOffset}px)
                        rotateY(${rotationY}deg)
                        rotateZ(${rotationZ}deg)
                        scale(${scale})
                        perspective(1000px)
                    `;

                    // Update segment character based on rotation
                    const newChar = this.getSegmentChar(index);
                    if (segment.element.textContent !== newChar) {
                        segment.element.textContent = newChar;
                    }

                    // Dynamic color shifting based on rotation and depth
                    const hueShift = (this.segmentRotations[index] * 20 + zOffset * 2) % 360;
                    if (index === 0) {
                        segment.element.style.filter = `hue-rotate(${hueShift}deg) brightness(${1.2 + Math.sin(this.time + index) * 0.2})`;
                    } else if (index === this.length - 1) {
                        segment.element.style.filter = `hue-rotate(${hueShift}deg) brightness(${0.8 + Math.sin(this.time + index) * 0.1})`;
                    } else {
                        segment.element.style.filter = `hue-rotate(${hueShift}deg) brightness(${1 + Math.sin(this.time + index) * 0.15})`;
                    }
                }
            });

            const energyElement = document.getElementById('energy');
            if (energyElement) {
                energyElement.textContent = Math.round(this.energy);
            }
        }

        animate() {
            if (this.isDestroyed) return;

            this.updateMovement();
            this.updateSegments();
            this.animationId = requestAnimationFrame(() => this.animate());
        }

        cleanup() {
            this.isDestroyed = true;

            if (this.animationId) {
                cancelAnimationFrame(this.animationId);
            }

            // Remove event listeners
            document.removeEventListener('mousemove', this.mouseMoveHandler);
            document.removeEventListener('mousedown', this.mouseDownHandler);
            document.removeEventListener('mouseup', this.mouseUpHandler);
            document.removeEventListener('keydown', this.keyDownHandler);

            // Clean up DOM elements
            if (this.playground) {
                const segments = this.playground.querySelectorAll('.centipede-segment, .particle');
                segments.forEach(segment => segment.remove());
            }

            this.segments = [];
        }
    }
</script>