@page "/companion"
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div id="playground">
    <div id="cursor"></div>
    <div id="info">
        <div>3D ASCII Centipede Companion</div>
        <div>Click: Feed • Hold: Attract</div>
        <div>State: <span id="state">Wandering</span></div>
        <div>Energy: <span id="energy">100</span>%</div>
    </div>
</div>


@code
{
    private IJSObjectReference? jsModule;
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("initializeCentipede");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error initializing centipede: {ex.Message}");
            }
        }
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("cleanupCentipede");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during cleanup: {ex.Message}");
        }

        if (jsModule != null)
        {
            await jsModule.DisposeAsync();
        }
    }
}

<script>
    let centipedeInstance = null;

    window.initializeCentipede = () => {
        if (centipedeInstance) {
            centipedeInstance.cleanup();
        }
        setTimeout(() => {
            centipedeInstance = new AsciiCentipede();
        }, 100);
    };

    window.cleanupCentipede = () => {
        if (centipedeInstance) {
            centipedeInstance.cleanup();
            centipedeInstance = null;
        }
    };

    class AsciiCentipede {
        constructor() {
            this.playground = document.getElementById('playground');
            this.cursor = document.getElementById('cursor');
            this.segments = [];
            this.length = 41;
            this.position = { x: window.innerWidth / 2, y: window.innerHeight / 2, z: 0 };
            this.velocity = { x: 0, y: 0, z: 0 };
            this.state = 'wandering';
            this.energy = 100;
            this.time = 0;
            this.mousePos = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
            this.isMouseDown = false;
            this.animationId = null;
            this.isDestroyed = false;

            // Mouse tracking
            this.lastMousePos = { x: this.mousePos.x, y: this.mousePos.y };
            this.lastMouseTime = performance.now();
            this.mouseVelocity = { x: 0, y: 0 };
            this.mouseSpeedEMA = 0;

            // Pattern movement properties - FULL PLAYGROUND PATTERNS
            this.patternState = 'none'; // 'none', 'square', 'bigcircle'
            this.squareCorner = 0;
            this.squareProgress = 0;
            this.squarePasses = 0;
            // Use 95% of playground dimensions for maximum visibility with small safety margin
            this.squareSize = Math.min(window.innerWidth, window.innerHeight) * 0.95;
            this.squareCenter = { x: window.innerWidth / 2, y: window.innerHeight / 2 };

            // Big circle pattern properties
            this.circleProgress = 0;
            this.circlePasses = 0;
            this.circlePhase = null;

            // 3D rotation angles
            this.segmentRotations = new Array(this.length).fill(0);
            this.rotationSpeeds = [];

            for (let i = 0; i < this.length; i++) {
                this.rotationSpeeds[i] = (Math.random() - 0.5) * 0.1;
            }

            this.asciiPatterns = [
                ['◊◈◇◉●', '○◦·∘◯', '◐◑◒◓◔', '◕◖◗◘◙', '◚◛◜◝◞'],
                ['▓▒░█▄', '▀■□▪▫', '◼◻▬▭▮', '▯▰▱▲▴', '▵▶▷▸▹'],
                ['※✱✲✳✴', '✵✶✷✸✹', '✺✻✼✽✾', '✿❀❁❂❃', '❄❅❆❇❈'],
                ['◆◇◈◉◊', '●◎◐◑◒', '◓◔◕◖◗', '◘◙◚◛◜', '◝◞◟◠◡'],
                ['⚬⚭⚮⚯⚰', '⚱⚲⚳⚴⚵', '⚶⚷⚸⚹⚺', '⚻⚼⚽⚾⚿', '⛀⛁⛂⛃⛄'],
                ['11111', '33333', '55555', '77777', '99999'],
                ['00000', '22222', '44444', '66666', '88888'],
                ['△▲▴▵⟁', '▽▼▾▿⧨', '◁◀◤◥◣', '▷▶◢◣◤', '⬒⬓⬔⬕⬖'],
                ['☉☼☀☁☂', '☃☄★☆✦', '✧✩✪✫✬', '✭✮✯✰✱', '☯☸☽☾☿'],
                ['∞∴∵∶∷', '∑∏√∫∆', '≡≠≈≪≫', '⊕⊗⊘⊙⊚', '∧∨⊤⊥∩'],
                ['▌▐█░▒▓', '╔═╗║╚╝', '┌─┬┐│└┴┘', '▁▂▃▄▅', '▆▇█▉▊'],
                ['←↑→↓↔', '⇐⇑⇒⇓⇕', '⟵⟶⟷⟸⟹', '➔➙➛➜➝', '↩↪↫↬↭'],
                ['♡♥❤❥❣', '☘✿❀❁❃', '⚘⚜✠✣✤', '✥✦✧★☆', '☄☀☁☂☃']
            ];

            this.currentPattern = 0;
            this.patternTimer = 0;

            if (this.playground) {
                this.init();
                this.bindEvents();
                this.animate();
            }
        }

        init() {
            if (!this.playground) return;

            // Clear any existing segments
            const existingSegments = this.playground.querySelectorAll('.centipede-segment');
            existingSegments.forEach(segment => segment.remove());

            // Create centipede segments
            for (let i = 0; i < this.length; i++) {
                const segment = document.createElement('div');
                segment.className = 'centipede-segment';
                if (i === 0) segment.classList.add('head');
                if (i === this.length - 1) segment.classList.add('tail');

                segment.style.cssText = `
                    position: absolute !important;
                    font-family: 'Consolas', monospace !important;
                    font-size: ${i === 0 ? '20px' : i === this.length - 1 ? '12px' : '16px'} !important;
                    font-weight: bold !important;
                    color: ${i === 0 ? '#ff6b6b' : i === this.length - 1 ? '#888' : '#e5e5e5'} !important;
                    text-shadow: 0 0 10px currentColor, 0 0 20px currentColor !important;
                    user-select: none !important;
                    z-index: ${1000 - i} !important;
                    width: auto !important;
                    height: auto !important;
                    display: inline-block !important;
                    margin: 0 !important;
                    padding: 0 !important;
                    border: none !important;
                    background: transparent !important;
                    letter-spacing: ${i === 0 ? '2px' : i === this.length - 1 ? '1px' : '3px'} !important;
                    transform-origin: center center !important;
                    transition: transform 0.1s ease-out !important;
                `;

                const initialX = this.position.x - i * 25;
                const initialY = this.position.y + Math.sin(i * 0.5) * 10;

                segment.textContent = this.getSegmentChar(i);
                segment.style.left = initialX + 'px';
                segment.style.top = initialY + 'px';

                this.playground.appendChild(segment);
                this.segments.push({
                    element: segment,
                    x: initialX,
                    y: initialY,
                    z: 0,
                    targetX: initialX,
                    targetY: initialY
                });
            }

            console.log(`Created ${this.segments.length} segments`);
        }

        getSegmentChar(index) {
            const pattern = this.asciiPatterns[this.currentPattern];
            const rotationIndex = Math.floor(this.segmentRotations[index]) % pattern.length;
            const segmentPattern = pattern[rotationIndex < 0 ? pattern.length + rotationIndex : rotationIndex];

            if (index === 0) {
                const headPatterns = ['►►►►►', '▶▶▶▶▶', '»»»»»', '→→→→→', '⟩⟩⟩⟩⟩'];
                const headIndex = Math.floor(this.segmentRotations[index] / 2) % headPatterns.length;
                return headPatterns[headIndex < 0 ? headPatterns.length + headIndex : headIndex];
            } else if (index === this.length - 1) {
                const tailPatterns = ['◦◦◦', '··', '∘', '○', '●'];
                const tailIndex = Math.floor(this.segmentRotations[index] / 3) % tailPatterns.length;
                return tailPatterns[tailIndex < 0 ? tailPatterns.length + tailIndex : tailIndex];
            } else {
                return segmentPattern;
            }
        }

        bindEvents() {
            this.mouseMoveHandler = (e) => {
                const now = performance.now();
                const dt = Math.max(1, now - this.lastMouseTime);

                const dx = e.clientX - this.lastMousePos.x;
                const dy = e.clientY - this.lastMousePos.y;
                const instSpeed = Math.hypot(dx, dy) / dt;

                const alpha = 0.3;
                this.mouseSpeedEMA += alpha * (instSpeed - this.mouseSpeedEMA);

                this.mouseVelocity.x = dx / dt;
                this.mouseVelocity.y = dy / dt;

                this.lastMousePos.x = e.clientX;
                this.lastMousePos.y = e.clientY;
                this.lastMouseTime = now;

                this.mousePos.x = e.clientX;
                this.mousePos.y = e.clientY;

                if (this.cursor) {
                    this.cursor.style.left = e.clientX - 10 + 'px';
                    this.cursor.style.top = e.clientY - 10 + 'px';
                }
            };

            this.mouseDownHandler = (e) => {
                this.isMouseDown = true;
                this.feed(e.clientX, e.clientY);
                if (this.patternState === 'none') {
                    this.setState('following');
                }
            };

            this.mouseUpHandler = () => {
                this.isMouseDown = false;
                setTimeout(() => {
                    if (!this.isMouseDown && this.patternState === 'none') {
                        this.setState('wandering');
                    }
                }, 1000);
            };

            document.addEventListener('mousemove', this.mouseMoveHandler);
            document.addEventListener('mousedown', this.mouseDownHandler);
            document.addEventListener('mouseup', this.mouseUpHandler);
        }

        setState(newState) {
            this.state = newState;
            const stateElement = document.getElementById('state');
            if (stateElement) {
                stateElement.textContent = this.capitalizeFirst(newState);
            }
        }

        capitalizeFirst(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        feed(x, y) {
            this.energy = Math.min(100, this.energy + 10);
            this.createParticles(x, y, '♥');
            if (this.patternState === 'none') {
                this.setState('eating');
                setTimeout(() => {
                    if (!this.isMouseDown && this.patternState === 'none') this.setState('wandering');
                }, 500);
            }
        }

        updateSegmentChars() {
            this.segments.forEach((segment, index) => {
                if (segment.element) {
                    segment.element.textContent = this.getSegmentChar(index);
                }
            });
        }

        createParticles(x, y, char) {
            if (!this.playground) return;

            for (let i = 0; i < 5; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.textContent = char;
                particle.style.left = (x + (Math.random() - 0.5) * 50) + 'px';
                particle.style.top = (y + (Math.random() - 0.5) * 50) + 'px';
                this.playground.appendChild(particle);

                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.remove();
                    }
                }, 3000);
            }
        }

        getSquareTarget() {
            const halfSize = this.squareSize / 2;
            // Use minimal padding to maximize pattern size - just 20px safety margin
            const padding = 20;
            const maxHalfSize = Math.min(
                (window.innerWidth - padding) / 2,
                (window.innerHeight - padding) / 2
            );
            const actualHalfSize = Math.min(halfSize, maxHalfSize);

            const corners = [
                { x: this.squareCenter.x - actualHalfSize, y: this.squareCenter.y - actualHalfSize }, // top-left
                { x: this.squareCenter.x + actualHalfSize, y: this.squareCenter.y - actualHalfSize }, // top-right
                { x: this.squareCenter.x + actualHalfSize, y: this.squareCenter.y + actualHalfSize }, // bottom-right
                { x: this.squareCenter.x - actualHalfSize, y: this.squareCenter.y + actualHalfSize }  // bottom-left
            ];

            const currentCorner = corners[this.squareCorner];
            const nextCorner = corners[(this.squareCorner + 1) % 4];

            const targetX = currentCorner.x + (nextCorner.x - currentCorner.x) * this.squareProgress;
            const targetY = currentCorner.y + (nextCorner.y - currentCorner.y) * this.squareProgress;

            return { x: targetX, y: targetY };
        }

        updateMovement() {
            if (this.isDestroyed) return;

            this.time += 0.05;

            // Prevent time overflow - reset every ~10 minutes to avoid precision issues
            if (this.time > 1000) {
                this.time = this.time % (Math.PI * 2); // Keep it within reasonable range
            }

            // Check for pattern triggers
            if (this.energy <= 50 && this.patternState === 'none' && !this.isMouseDown) {
                // Recalculate maximum square size when pattern starts - nearly full playground
                this.squareSize = Math.min(window.innerWidth, window.innerHeight) * 0.95;
                this.squareCenter = { x: window.innerWidth / 2, y: window.innerHeight / 2 };

                this.patternState = 'square';
                this.squareCorner = 0;
                this.squareProgress = 0;
                this.squarePasses = 0;
                this.setState('square pattern');
                console.log(`Starting maximum square pattern - size: ${this.squareSize}px (95% of playground)`);
            }

            if (this.patternState === 'square') {
                const target = this.getSquareTarget();
                const head = this.segments[0];

                const dx = target.x - head.x;
                const dy = target.y - head.y;
                const dist = Math.hypot(dx, dy);

                if (dist < 15) { // tolerance for reaching a corner
                    this.squareProgress = 0;
                    this.squareCorner = (this.squareCorner + 1) % 4;

                    if (this.squareCorner === 0) {
                        // completed one full lap
                        this.squarePasses = (this.squarePasses || 0) + 1;

                        if (this.squarePasses >= 2) { // after 2 laps, switch to big circle
                            this.patternState = 'bigcircle';
                            this.circleProgress = 0;
                            this.circlePasses = 0;
                            this.circlePhase = null;
                            this.setState('big circle pattern');
                            this.squarePasses = 0; // reset counter
                            console.log('Switching to big circle pattern');
                            return;
                        }
                    }
                }

                const speed = 12; // head speed on square (10 + 20% = 12)
                this.velocity.x = (dx / dist) * speed;
                this.velocity.y = (dy / dist) * speed;

                head.targetX = head.x + this.velocity.x;
                head.targetY = head.y + this.velocity.y;

                this.energy = Math.max(0, this.energy - 0.05);
            } else if (this.patternState === 'bigcircle') {
                const head = this.segments[0];
                const centerX = this.squareCenter.x;
                const centerY = this.squareCenter.y;

                // Calculate circle radius - use 80% of available space for safety
                const maxRadius = Math.min(
                    (window.innerWidth - 40) / 2,   // 20px padding on each side
                    (window.innerHeight - 40) / 2   // 20px padding top and bottom
                ) * 0.8; // Use 80% for comfortable margin

                // Always advance the circle progress to keep moving
                this.circleProgress += 0.004; // Constant circular motion speed

                // Smooth circular motion - counter-clockwise starting from top
                const angle = this.circleProgress * Math.PI * 2 - Math.PI / 2; // Start at top (-π/2)
                const targetX = centerX + maxRadius * Math.cos(angle);
                const targetY = centerY + maxRadius * Math.sin(angle);

                // Calculate velocity to move toward the target position
                const dx = targetX - head.x;
                const dy = targetY - head.y;
                const dist = Math.hypot(dx, dy) || 1; // Prevent division by zero
                const speed = 15; // Consistent movement speed

                // Set velocity to move toward target
                this.velocity.x = (dx / dist) * speed;
                this.velocity.y = (dy / dist) * speed;

                // Update head target position
                head.targetX = head.x + this.velocity.x;
                head.targetY = head.y + this.velocity.y;

                // Check if we completed a full circle
                if (this.circleProgress >= 1.0) {
                    this.circleProgress = 0; // Reset for next circle
                    this.circlePasses++;
                    console.log(`Completed circle ${this.circlePasses} - Energy: ${Math.round(this.energy)}%`);
                }

                // Gradually restore energy during circle pattern
                this.energy = Math.min(100, this.energy + 0.035);

                // Continue circling until energy reaches 100%
                if (this.energy >= 100) {
                    this.patternState = 'none';
                    this.setState('wandering');
                    this.circlePhase = null;
                    this.circlePasses = 0;
                    console.log(`Big circle pattern complete - Energy restored to ${Math.round(this.energy)}% - returning to wandering`);
                    return;
                }
            } else {
                // Normal wandering/following behavior
                this.energy = Math.max(0, this.energy - 0.02);

                this.patternTimer++;
                if (this.patternTimer > 300) {
                    this.patternTimer = 0;
                    this.currentPattern = (this.currentPattern + 1) % this.asciiPatterns.length;
                    this.updateSegmentChars();
                }

                if (this.segments.length > 0) {
                    const head = this.segments[0];

                    if (this.state === 'following' && this.isMouseDown) {
                        const dx = this.mousePos.x - head.x;
                        const dy = this.mousePos.y - head.y;
                        const dist = Math.hypot(dx, dy) || 1;

                        const dirX = dx / dist;
                        const dirY = dy / dist;

                        const kMouse = 16 * 1.0;
                        const kBase = 1.4;
                        let desiredSpeed = kBase + kMouse * this.mouseSpeedEMA;

                        const deadzone = 30;
                        if (dist < deadzone) {
                            desiredSpeed *= (dist / deadzone);
                        }

                        const maxSpeed = Math.max(3.0, Math.min(6.0, desiredSpeed * 1.5));
                        desiredSpeed = Math.min(desiredSpeed, maxSpeed);

                        const vTargetX = dirX * desiredSpeed;
                        const vTargetY = dirY * desiredSpeed;

                        const responsiveness = 0.22;
                        this.velocity.x += (vTargetX - this.velocity.x) * responsiveness;
                        this.velocity.y += (vTargetY - this.velocity.y) * responsiveness;

                    } else {
                        this.velocity.x += (Math.random() - 0.5) * 0.36;
                        this.velocity.y += (Math.random() - 0.5) * 0.36;
                        this.velocity.x += Math.sin(this.time * 0.5) * 0.24;
                        this.velocity.y += Math.cos(this.time * 0.3) * 0.24;
                    }

                    const energyMultiplier = (this.energy / 100) * 1 + 0.5;
                    this.velocity.x *= energyMultiplier;
                    this.velocity.y *= energyMultiplier;

                    this.velocity.x *= 0.95;
                    this.velocity.y *= 0.95;

                    const vMag = Math.hypot(this.velocity.x, this.velocity.y);
                    const hardMax = 6.0;
                    if (vMag > hardMax) {
                        this.velocity.x = (this.velocity.x / vMag) * hardMax;
                        this.velocity.y = (this.velocity.y / vMag) * hardMax;
                    }

                    head.targetX += this.velocity.x;
                    head.targetY += this.velocity.y;

                    head.targetX = Math.max(20, Math.min(window.innerWidth - 20, head.targetX));
                    head.targetY = Math.max(20, Math.min(window.innerHeight - 20, head.targetY));

                    if (head.x <= 0 || head.x >= window.innerWidth) this.velocity.x *= -0.8;
                    if (head.y <= 0 || head.y >= window.innerHeight) this.velocity.y *= -0.8;
                }
            }
        }

        updateSegments() {
            if (this.isDestroyed || this.segments.length === 0) return;

            // Head follows its target position
            this.segments[0].x += (this.segments[0].targetX - this.segments[0].x) * 0.25;
            this.segments[0].y += (this.segments[0].targetY - this.segments[0].y) * 0.25;

            let targetDistance = this.patternState !== 'none' ? 45 : 25;//added..
            let followSpeed   = this.patternState !== 'none' ? 0.8 : 0.3;

            if (this.patternState !== 'none') {
                // During patterns, allow much more stretching and faster following
                targetDistance = 45; // Allow segments to be much further apart
                followSpeed = 0.6; // Follow faster to keep up with head movement
            }

            // Body segments follow the segment in front of them
            for (let i = 1; i < this.segments.length; i++) {
                const prev = this.segments[i - 1];
                const seg = this.segments[i];

                // Distance to previous segment
                const dx = prev.x - seg.x;
                const dy = prev.y - seg.y;
                const dist = Math.hypot(dx, dy);

                const followDistance = 20; // spacing between segments
                if (dist > followDistance) {
                    const ratio = followDistance / dist;
                    seg.targetX = prev.x - dx * ratio;
                    seg.targetY = prev.y - dy * ratio;
                } else {
                    seg.targetX = seg.x;
                    seg.targetY = seg.y;
                }

                // Smoothly move toward target
                seg.x += (seg.targetX - seg.x) * 0.4;
                seg.y += (seg.targetY - seg.y) * 0.4;
            }
            const head = this.segments[0];
            head.x += (head.targetX - head.x) * 0.5;
            head.y += (head.targetY - head.y) * 0.5;

            // Update visual elements for all segments
            this.segments.forEach((segment, index) => {
                if (segment.element) {
                    segment.element.style.left = segment.x + 'px';
                    segment.element.style.top = segment.y + 'px';

                    // Calculate rotation values with bounded time to prevent overflow (faster rotation starting from head)
                    const patternSpeedBoost = (this.patternState !== 'none') ? 2 : 1;
                    const baseRotationSpeed = 0.5 * 1.5 * (this.energy / 50 + 0.5) * patternSpeedBoost; // 0.035 * 1.15 = 0.04025
                    const speed = Math.hypot(this.velocity.x, this.velocity.y);
                    const movementBoost = speed * 0.03 * 1.5; // 0.02 * 1.15 = 0.023
                    this.segmentRotations[index] = this.time * (baseRotationSpeed + movementBoost) + index * 0.3;


                    // Use modular arithmetic to keep rotation values bounded - rotation starts from head (index 0)
                    const rotationBase = (this.time * (baseRotationSpeed + movementBoost) + (this.length - 1 - index) * 0.3) % (Math.PI * 2);
                    //this.segmentRotations[index] = rotationBase;

                    const zOffset = Math.sin(this.time + index * 0.2) * 5;
                    const rotationY = this.segmentRotations[index] * 10;
                    const rotationZ = Math.sin(this.time * 0.5 + index * 0.3) * 5;
                    const scale = 1 + (Math.sin(rotationBase) * 0.1);

                    segment.element.style.transform = `
                        translateZ(${zOffset}px)
                        rotateY(${rotationY}deg)
                        rotateZ(${rotationZ}deg)
                        scale(${scale})
                        perspective(1000px)
                    `;

                    const newChar = this.getSegmentChar(index);
                    if (segment.element.textContent !== newChar) {
                        segment.element.textContent = newChar;
                    }

                    // Keep hue values bounded to prevent color overflow
                    const patternHueBoost = (this.patternState !== 'none') ? 50 : 0;
                    const hueShift = ((rotationBase * 20) + (zOffset * 2) + patternHueBoost) % 360;
                    if (index === 0) {
                        segment.element.style.filter = `hue-rotate(${hueShift}deg) brightness(${1.2 + Math.sin(this.time + index) * 0.2})`;
                    } else if (index === this.length - 1) {
                        segment.element.style.filter = `hue-rotate(${hueShift}deg) brightness(${0.8 + Math.sin(this.time + index) * 0.1})`;
                    } else {
                        segment.element.style.filter = `hue-rotate(${hueShift}deg) brightness(${1 + Math.sin(this.time + index) * 0.15})`;
                    }
                }
            });

            const energyElement = document.getElementById('energy');
            if (energyElement) {
                energyElement.textContent = Math.round(this.energy);
            }
        }

        animate() {
            if (this.isDestroyed) return;
            this.updateMovement();
            this.updateSegments();
            this.animationId = requestAnimationFrame(() => this.animate());
        }

        cleanup() {
            this.isDestroyed = true;
            if (this.animationId) {
                cancelAnimationFrame(this.animationId);
            }
            document.removeEventListener('mousemove', this.mouseMoveHandler);
            document.removeEventListener('mousedown', this.mouseDownHandler);
            document.removeEventListener('mouseup', this.mouseUpHandler);
            if (this.playground) {
                const segments = this.playground.querySelectorAll('.centipede-segment, .particle');
                segments.forEach(segment => segment.remove());
            }
            this.segments = [];
        }
    }
</script>